datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ------------------ ENUMS ------------------

enum Gender {
  male
  female
  other
}

enum MessageType {
  text
  image
  emoji
}

enum LikeStatus {
  pending
  matched
}

// ------------------ MODELS ------------------

// Users
model User {
  id             String     @id @default(uuid())
  phone          String?    @unique
  email          String?    @unique
  passwordHash   String?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  lastActiveAt   DateTime?

  profile        Profile?
  likesGiven     Like[]     @relation("LikesGiven")
  likesReceived  Like[]     @relation("LikesReceived")
  matches1       Match[]    @relation("MatchesUser1")
  matches2       Match[]    @relation("MatchesUser2")
  messages       Message[]
  blocksGiven    Block[]    @relation("BlocksGiven")
  blocksReceived Block[]    @relation("BlocksReceived")
}

// Profiles
model Profile {
  id          String   @id @default(uuid())
  userId      String   @unique
  displayName String
  age         Int
  gender      Gender
  bio         String?
  interests   Json?
  photos      Json?
  location    Bytes?   // store POINT(lat,long) as raw binary (PostGIS)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Likes
model Like {
  id        String     @id @default(uuid())
  likerId   String
  likedId   String
  createdAt DateTime   @default(now())
  status    LikeStatus @default(pending)

  liker     User       @relation("LikesGiven", fields: [likerId], references: [id], onDelete: Cascade)
  liked     User       @relation("LikesReceived", fields: [likedId], references: [id], onDelete: Cascade)

  @@unique([likerId, likedId])
}

// Matches
model Match {
  id        String   @id @default(uuid())
  user1Id   String
  user2Id   String
  matchedAt DateTime @default(now())
  isActive  Boolean  @default(true)

  user1     User     @relation("MatchesUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User     @relation("MatchesUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages  Message[]

  @@unique([user1Id, user2Id])
}

// Messages
model Message {
  id          String      @id @default(uuid())
  matchId     String
  senderId    String
  content     String?
  messageType MessageType @default(text)
  createdAt   DateTime    @default(now())
  isRead      Boolean     @default(false)

  match       Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender      User        @relation(fields: [senderId], references: [id], onDelete: Cascade)
}

// Blocks
model Block {
  id         String   @id @default(uuid())
  blockerId  String
  blockedId  String
  reason     String?
  createdAt  DateTime @default(now())

  blocker    User     @relation("BlocksGiven", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked    User     @relation("BlocksReceived", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
}